# chapter02 데이터

## 02-1 0과 1로 숫자를 표현하는 방법
---
<br>

### 정보 단위
**bit** : 0과 1을 나타내는 가장 작은 정보 단위.  

정보를 저장하고 연산을 수행하기 위해 컴퓨터는 비트(bit)라는 측정 단위를 쓴다.
비트는 이진 숫자라는 뜻을 가진 **binary digit**의 줄임말이며, 0과 1, 두 가지 값만 가질 수 있다.

![비트](https://cphinf.pstatic.net/mooc/20171117_70/1510912069789p09Nl_JPEG/1.1_-01.jpg?type=w760)


프로그램의 크기를 말할 때, 표현의 편의를 위해 비트보다 큰 단위를 사용한다.

<br>

|단위|사이즈|
|:---:|:---:|
|1바이트 (1byte)|8비트 (8bit)|
|1메가바이트 (1MB)|1,000바이트 (1,000byte)|
|1기가바이트 (1GB)|1,000메가바이트 (1,000MB)|
|1테라바이트 (1TB)|1,000기가바이트 (1,000GB)|

모두 **1,000**개씩 묶어 표현하고 있다.

<br>

1kb를 1,024kb. 1MB는 1,024kb... 로 표현하는 것은 잘못된 관습이다.  
이전 단위를 **1,024**개 묶어 표현한 단위는 **KiB, MiB, GiB, TiB**이다.

<br><br>

### 워드(word)란?
CPU가 한 번에 처리할 수 있는 데이터 크기.
만약 CPU가 한 번에 16비트를 처리할 수 있다면 1 워드는 16비트가 된다.

* 하프 워드(half word) - 워드의 절반 크기
* 풀 워드(full word) - 워드의 1배 크기
* 더블 워드(double word) - 워드의 2배 크기

<br>

### 이진법

1을 넘어가는 시점에 자리 올림을 하여 0과 1만으로 모든 수를 표현하는 방법.

2진법은 전기를 통해 연산하는, 즉 전기를 켜고 끄는 방식으로 작동하는 컴퓨터에게 적합하다.

컴퓨터에는 굉장히 많은 스위치(트렌지스터)가 있고 on/off 상태를 통해 0과 1을 표현한다.

우리가 흔히 사용하는 10진법을 예를 들어보자.

우리가 123을 '백이십삼'으로 읽는 이유는 1을 백의자리, 2를 십의자리, 3을 일의자리로 보기 때문이다.

![10진법 자리수](https://cphinf.pstatic.net/mooc/20200607_185/1591510753380nYdg2_PNG/mceclip1.png)

위의 그림과 같이 10진법으로 123을 표현하면 **1x100 + 2x10 + 3x1 = 123**이 된다.

2진법에서는 두 개의 숫자만 있으므로 각 자리수가 **2의 거듭제곱**을 의미한다.

![2진법 자리수](https://cphinf.pstatic.net/mooc/20200607_209/1591512453958WWybq_PNG/mceclip2.png)

이 방법으로 2진법으로 10진법의 3을 표현하면 아래와 같다.

![2진법 3](https://cphinf.pstatic.net/mooc/20200607_19/1591512545601J5dkm_PNG/mceclip3.png)

2진법에서 11은 **2¹x1 + 1x1 = 3**이다.

<br><br>

### 이진수의 음수 표현
**부호 절댓값을 사용하는 음수 표현**

하나의 비트를 사용해 양수와 음수를 구별하는 것.
가장 직관적이고 간단하게 표현할 수 있다.

|10진법|2진법|
|:---:|:---:|
|3|0011|
|2|0010|
|1|0001|
|+0|0000|
|-0|1000|
|-1|1001|
|-2|1010|
|-3|1100|

표를 잘 보면 최상위 비트에서 양수들은 0, 음수는 1을 사용한다는걸 알 수 있다.

하지만 이런 식으로 음수를 표현하면 몇 가지 단점이 있다.

1. 0을 표현할때 -0 과 +0 으로 불필요하게 나누어 짐.
2. 두 수의 덧셈을 할 때 문제가 생김.

<br>

> 4bit 2진수 5와 -5 더하기

$$ \text{　}0101 $$
$$+1101 $$
---
$$ 10010 $$

최상위 비트의 자리 올림수를 제외하면 덧셈의 결과는 0010으로 **2**가 된다.<br>

5+(-5)는 0이 나와야하는데 일반적인 덧셈 방법으로는 예상과 다른 결과가 나온다.

이를 개선하기 위해서는 부호값을 분리하여 뺄셈을 따로하는 방법을 사용해야 한다.

아래의 보수 표현법을 보자.
<br><br>

## 여기서 잠깐!
컴퓨터는 **덧셈**밖에 못한다!
컴퓨터 내부에서는 사칙연산을 할 때 덧셈을 담당하는 가산기(Adder)만 이용하기 때문에 뺄셈은 덧셈으로 형식을 변환하여 계산해야 한다.  
즉 컴퓨터 내부에서는 A - B를 계산할 때 B의 보수(-B)를 구한 다음 A + (-B)로 계산한다.

그럼 보수는 무엇일까?

<br>

>### 보수란?
>컴퓨터에서 음의 정수를 표현하기 위해서 고안되었다. <br>
각 자리의 숫자 합이 일정한 값이 되는 것이다. 즉 일정한 값을 만들기 위해 보충해주는 숫자이다. <br>
이러한 방식으로 어떤 수의 뺄셈은 주어진 수의 보수를 더하는 방식으로 이루어진다. <br><br>

> **r진법의 보수**
>* (r-1)의 보수 : 자릿수 에서 가질 수 있는 최댓값 - n
>* r의 보수: (r-1)의 보수 + 1

-> 즉, 2의 보수를 구할때는 1의 보수를 구한 후 + 1을 함.

<br><br>

**1의 보수를 사용하는 음수 표현**

1의 보수를 구하는 방법은 모든 자리수를 반대로 뒤집는 것이다.  
1 은 0으로 0은 1로.  
아래 표는 1의 보수로 음수를 표현한 것이다.

|10진법|2진법|10진법|2진법|
|:---:|:---:|:---:|:---:|
|3|0011|-3|1100|
|2|0010|-2|1101|
|1|0001|-1|1110|
|+0|0000|-0|1111|

부호 절대값 방식과 같이 0의 표현이 -0과 +0 두가지로 나누어 진다.

<br><br>


**2의 보수를 사용하는 음수 표현**

1의 보수에서 1을 더한다. 아래의 예시를 보자.

>**2진수 1010에 대한 2의 보수 구하기**
>1. 1010에 대한 1의 보수 0101을 구함.
>2. 0101에 +1을 더함
>3. 0110이란 값을 얻음.

아래의 표는 2의 보수로 음수를 표현한 것이다.

<br>

|10진법|2진법|10진법|2진법|
|:---:|:---:|:---:|:---:|
|3|0011|-3|1101|
|2|0010|-2|1110|
|1|0001|-1|1111|
|0|0000|

1의 보수와 달리 2의 보수로 표현하면 0을 하나로 표현할 수 있다.

<br>

**1의 보수와 2의 보수 덧셈 비교**

3+(-2)를 하는 경우.

1. 2의 보수
$$\text{  } 011   $$
$$+110   $$
---
$$  1001   $$
$$  001   $$
-> 더하면 1001이 나오나 자리 올림수(carry)인 맨 앞의 1을 버린다.

2. 1의 보수
$$\text{  } 011   $$
$$+101   $$
---
$$  1000   $$
$$  001   $$
-> 더하면 1000이 나오나 자리 올림수(carry)인 맨 앞의 1을 더해준다.

**즉 1의 보수는 한번의 연산이 더 필요한 경우가 생긴다.**

즉 1의 보수는
* 0이 +- 두가지 형태로 표현됨.
* 1의 보수로 덧셈 연산을 할 경우 한번의 연산이 더 필요한 경우가 생김.

**따라서 2의 보수로 연산하는 경우가 보편적이다.**

<br><br>

### 16진수

수가 15를 넘어가는 시점에 자리 올림을 하는 숫자 표현 방식. 코드상에서는 주로 앞에 **0x**를 붙여 16진수를 표기함.

<br>

**10진수, 2진수, 8진수, 16진수 비교표**

![진수세기](https://t1.daumcdn.net/cfile/tistory/990ED8485CBA7C990A)


![16진수로 나타내기](https://velog.velcdn.com/images%2Fbining%2Fpost%2Ffe131d72-da9a-4f98-94de-c4a27add27df%2Fimage.png)


<br><br>

---
<br>

## 02-2 0과 1로 문자를 표현하는 방법

### 문자 집합과 인코딩

* 문자 집합 - 컴퓨터가 인식하고 표현할 수 있는 문자의 모음
* 문자 인코딩 - 문자를 0과 1로 변환하는 과정. 인코딩 후 0과 1로 이루어진 결과값이 문자 코드가 됨.
* 문자 디코딩 - 인코딩의 반대 과정. 즉, 0과 1로 이루어진 문자 코드를 사람이 이해할 수 있는 문자로 변환하는 과정.

### 아스키(ASCII) 코드
초창기 문자 집합 중 하나. 영어 알파벳, 아라비아 숫자, 일부 특수 문자를 포함함.

아스키 문자들은 각각 7비트로 표현됨.
$$ 2^7 = 128 $$
총 128개의 문자를 표현할 수 있다.

>실제로는 하나의 아스키 문자를 나타내기 위해 8비트 (1바이트)를 사용한다. 하지만 8비트 중 1비트는 패리티 비트(parity bit)라고 불리는, 오류 검출을 위해 사용되는 비트이기 때문에 실질적으로 문자 표현을 위해 사용되는 비트는 7비트이다.

<br>

**확장 아스키 (Extended ASCII)**
* 기존 아스키에 1비트를 추가한 8비트 문자 코드
* 표현 가능한 문자의 수는 256개

<br>

한글 인코딩에는 두 가지 방식이 있다. 

**완성형 인코딩**
* 초성, 중성, 종성의 조합으로 이루어진 완성된 하나의 글자에 고유한 코드를 부여하는 방식.
* '가' - 11101010

**조합형 인코딩**
* 초성을 위한 비트열, 중성을 위한 비트열, 종성을 위한 비트열을 할당하여 그것들의 조합으로 하나의 글자 코드를 완성하는 인코딩 방식.
* 'ㄱ' + 'ㅏ' - 1010 + 0011 = 1010 0011

<br>

![완성형, 조합형 이미지](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F24144A485471E06F24)

<br>

### EUC-KR
대표적인 완성형 인코딩 방식으로 초성, 중성, 종성이 모두 결합된 한글 단어에 2바이트 크기의 코드를 부여한다.

* 총 2,350개 정도의 한글 단어 표현 가능.
* 모든 한글 조합을 표현할 수는 없음.
* 이를 해결하기 위해 CP949가 등장함. (EUC-KR 확장 버전)

**16진수로 표현된 EUC-KR 표**
![16진수로 표현된 EUC-KR](https://goodgid.github.io/assets/img/tech/String-Encoding_2.png)
가는 b0a1로 인코딩 된다.

<br>

### 유니코드와 UTF-8
유니코드 - 한글을 포함하여 대부분 나라의 문자, 특수문자, 화살표나 이모티콘까지 코드로 표현할 수 있는 통일된 문자 집합.

유니코드 문자 집합에서는 아스키 코드와 같이 각 문자마다 고유한 값이 부여됨.

![유니코드](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQY4i0ks7hOxbKRm0-EG1EKLQnI-9XrA48vLA&usqp=CAU)

유니코드 앞에 U+라는 문자열이 붙어있으면 16진수 유니코드.

UTF - 유니코드를 인코딩 하는 방식을 나타낸다.

UTF 는 몇 bit를 사용하여 index를 표현할 것인가를 뜻한다.

* UTF-8은 8bit를 사용하여 1개의 Index를 표현.

* UTF-16은 16bit를 사용하여 1개의 Index를 표현.

* UTF-32는 32bit를 사용하여 1개의 Index를 표현.

**UTF-8이 가장 대중적인 유니코드 인코딩 방식이다.**

UTF-8은 통상 1바이트 ~ 4바이트까지의 인코딩 결과를 만든다.

|첫 코드 포인트|마지막 코드 포인트|1바이트|2바이트|3바이트|4바이트|
|:---:|:---:|:---:|:---:|:---:|:---:|
|0000|007F|0XXXXXXX||||
|0080|07FF|110XXXXX|10XXXXXX|||
|0800|FFFF|1110XXXX|10XXXXXX|10XXXXXX|||
|10000|10FFFF|11110XXX|10XXXXXX|10XXXXXX|10XXXXXX|

* 유니코드 문자에 부여된 값의 범위가 0부터 007F까지는 1바이트로 표현
* 유니코드 문자에 부여된 값의 범위가 0080부터 07FF까지는 2바이트로 표현

UTF-8로 인코딩한 결과가 몇 바이트가 될지는 유니코드 문자에 부여된 값의 범위에 따라 결정된다.

<br><br>










